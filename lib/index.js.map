{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["\nexport Plugin from './types/Plugin'\nexport Faker from './types/Faker'\nexport Computed from './types/Computed'\nexport Static from './types/Static'\n\nimport {compose, range} from 'freshman'\n\nclass Generator {\n  constructor(Model, count) {\n    this.type = Model.name\n    this.model = Model\n    this.count = count\n  }\n}\n\n// generateDescriptor :: GeneratorType -> Model\nconst generateDescriptor = (db, gen) => new gen.model(db)\n\n// processLeaf :: LeafNode -> Database -> Object\nconst processLeaf = l => l.run()\n\n// processDescriptor :: Model -> ProcessedObject\nconst processDescriptor = (d) => {\n  return Object.keys(d).reduce((acc, k) => {\n    let obj = d[k]\n\n    // Process a complex object recursively\n    function recursiveCall(obj) {\n      if (obj.run) {\n        return processLeaf(obj)\n      } else if(typeof obj == \"object\") {\n        return Object.keys(obj).reduce((acc, k) => {\n          acc[k] = recursiveCall(obj[k])\n          return acc;\n        }, {});\n      }\n    }\n\n    acc[k] = recursiveCall(obj)\n    return acc\n  }, {})\n}\n\nconst cleanVirtuals = (descriptor, instance) => {\n  let virtuals = descriptor.constructor.virtuals\n  virtuals.forEach(k => delete instance[k])\n}\n\nclass Mocker {\n\n  schemas = [];\n\n  reset() {\n    this.schemas = []\n  }\n\n  schema(Model, count) {\n    this.schemas.push(new Generator(Model, count))\n    return this\n  }\n\n  getDescriptors() {\n    return this.schemas.reduce((acc, schema) => {\n      let desc = generateDescriptor(acc, schema)\n      acc[schema.type] = desc\n      return acc\n    }, {})\n  }\n\n  build() {\n    return this.schemas.reduce((acc, schema) => {\n\n      // Generate a descriptor for schema\n      let desc = generateDescriptor(acc, schema)\n\n      // Generate instances from descriptor\n      let instances = range(0, schema.count)\n        .map(() => processDescriptor(desc))\n\n      // Clean\n      instances.forEach(x => cleanVirtuals(desc, x))\n\n      acc[schema.type] = instances\n      return acc\n    }, {})\n  }\n}\n\nexport const mocker = new Mocker()\n"]}